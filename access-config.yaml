apiVersion: v1
kind: ConfigMap
metadata:
  name: access-config
data:
  # ============================================================
  # [1] REST + Page 설정 (nginx-rest.conf)
  # ============================================================
  nginx-rest.conf: |
    worker_processes auto;

    # [수정] 표준 경로 사용
    pid /tmp/nginx.pid;

    events { worker_connections 1024; }

    http {
        include /etc/nginx/mime.types;
        default_type application/octet-stream;
        sendfile on;

        # 임시 경로 권한 문제 방지
        client_body_temp_path /tmp/client_temp;
        proxy_temp_path       /tmp/proxy_temp_path;
        fastcgi_temp_path     /tmp/fastcgi_temp;
        uwsgi_temp_path       /tmp/uwsgi_temp;
        scgi_temp_path        /tmp/scgi_temp;

        # Upstream 정의
        upstream fcgi_backend {
            least_conn;
            server unix:/var/run/xt/rest_1.sock;
            server unix:/var/run/xt/rest_2.sock;
            server unix:/var/run/xt/rest_3.sock;
            server unix:/var/run/xt/rest_4.sock;
            server unix:/var/run/xt/rest_5.sock;
            server unix:/var/run/xt/rest_6.sock;
        }

        # [A] 페이지 전용 (30145)
        server {
            listen 30145;
            server_name page-server;
            root /home/xt_rest/wproj/src/pages;
            index XtHomePage.html;
            location = / { try_files $uri $uri/ /XtHomePage.html; }
            location = /api/ping { return 200 'pong'; add_header Content-Type text/plain; }

            location = /platform/rest-tr-fcgi { rewrite ^ /platform/rest_tr_fcgi.html; }
            location = /platform/wsock-real   { rewrite ^ /platform/wsock_real.html; }
            location = /mon_ch                { rewrite ^ /monitor/monitor_main.html; }
            location = /mon_cron              { rewrite ^ /monitor/XtCRON_Monitor.html; }
            location = /kr_fcgi               { rewrite ^ /krtest/kr_fcgi.html; }
            location = /kr_wsock              { rewrite ^ /krtest/kr_wsock.html; }
            location = /trad_restful          { rewrite ^ /trading/trad_restful.html; }
            location = /trad_websocket        { rewrite ^ /trading/trad_websocket.html; }
            location = /trad_index            { rewrite ^ /trading/trad_index.html; }

            location = /svrauto_buy           { rewrite ^ /trading/svrauto_buy.html; }
            location = /svrauto_sell          { rewrite ^ /trading/svrauto_sell.html; }
            location = /svrauto_sell_ts       { rewrite ^ /trading/svrauto_sell_ts.html; }
            location = /svrauto_cond_list     { rewrite ^ /trading/svrauto_cond_list.html; }

            location /trad_admin { rewrite ^ /trading/trad_admin.html; }
            location /public/ { alias /home/xt_rest/wproj/src/pages/trading/public/; }

        }

        # [B] REST API 전용 (30045)
        server {
            listen 30045;
            server_name rest-api-server;

            location /XtFCGI {
                # [수정] 표준 로그 경로 사용 (/var/log/nginx/...)
                access_log /var/log/nginx/access_xtfcgi.log;

                # 헤더 정리
                fastcgi_hide_header Access-Control-Allow-Origin;
                fastcgi_hide_header Access-Control-Allow-Methods;
                fastcgi_hide_header Access-Control-Allow-Headers;
                fastcgi_hide_header Access-Control-Allow-Credentials;

                # [수정] 표준 fastcgi_params 경로 사용 (/etc/nginx/...)
                include /etc/nginx/fastcgi_params;

                # [수정] 위에서 정의한 upstream 이름과 일치시킴 (fcgi_backend)
                fastcgi_pass fcgi_backend;

                # 기존 유지
                fastcgi_param SCRIPT_FILENAME /home/xt_rest/Xt/src/rest/XtFCGI/XtFCGI;
                fastcgi_param HTTP_AUTHORIZATION $http_authorization;

                # CORS 설정
                add_header Access-Control-Allow-Origin "*" always;
                add_header Access-Control-Allow-Methods "GET, POST, OPTIONS" always;
                add_header Access-Control-Allow-Headers "Authorization, Content-Type" always;
                add_header Vary "Origin" always;

                if ($request_method = OPTIONS) { return 204; }
            }

            location = /api/ping { return 200 'pong'; }
        }
    }

  # ============================================================
  # [2] WebSocket 설정 (nginx-wsock.conf)
  # ============================================================
  nginx-wsock.conf: |
    worker_processes auto;
    pid /tmp/nginx.pid;
    events { worker_connections 1024; }
    http {
        client_body_temp_path /tmp/client_temp;
        proxy_temp_path       /tmp/proxy_temp_path;
        fastcgi_temp_path     /tmp/fastcgi_temp;
        uwsgi_temp_path       /tmp/uwsgi_temp;
        scgi_temp_path        /tmp/scgi_temp;

        # 스크립트로 생성한 유닉스도메인소켓 경로 불러오기
        include /etc/nginx/conf.d/wsock_upstream.conf;
        server {
            listen 30046;
            location /wsock {
                rewrite ^/wsock/?(.*)$ / break;
                proxy_pass http://wsock_backend;
                proxy_http_version 1.1;
                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection "Upgrade";
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_read_timeout 3600s;
                proxy_send_timeout 3600s;
            }
        }
    }

  haproxy.cfg.tpl: |
    global
        log stdout format raw local0
        maxconn 200000

    defaults
        log global
        option httplog
        timeout connect 3s
        timeout client  3600s
        timeout server  3600s
        timeout http-request 10s
        timeout http-keep-alive 30s
        timeout tunnel  2h

    frontend fe_wsock
        bind :30046
        mode http
        default_backend be_wsock

    backend be_wsock
        mode http
        balance leastconn
        __SERVERS__
#__SERVERS__는 스크립트에서 치환됨

  run_haproxy.sh: |
    #!/bin/sh
    set -eu

    TPL="/etc/haproxy/haproxy.cfg.tpl"
    OUT="/tmp/haproxy.cfg"

    PROCESS_COUNT="${PROCESS_COUNT:-6}"
    THREAD_COUNT="${THREAD_COUNT:-4}"

    SOCK_DIR="${SOCK_DIR:-/var/run/xt}"
    SOCK_PREFIX="${SOCK_PREFIX:-wsock}"
    SERVER_MAXCONN="${SERVER_MAXCONN:-5000}"

    echo "[haproxy] PROCESS_COUNT=$PROCESS_COUNT"
    echo "[haproxy] THREAD_COUNT=$THREAD_COUNT"
    echo "[haproxy] SOCK_DIR=$SOCK_DIR SOCK_PREFIX=$SOCK_PREFIX"

    # 기대 소켓 개수만큼 기다리기 (최대 10초: 0.1s * 100)
    expected=$((PROCESS_COUNT * THREAD_COUNT))
    i=0
    while [ "$i" -lt 100 ]; do
        # 실제 존재하는 소켓 개수
        cnt=$(ls -1 "${SOCK_DIR}/${SOCK_PREFIX}_"*.sock 2>/dev/null | wc -l | tr -d ' ')
        if [ "$cnt" -ge "$expected" ]; then
        break
        fi
        i=$((i+1))
        sleep 0.1
    done
    echo "[haproxy] found_sockets=${cnt:-0} expected=$expected"

    # 존재하는 소켓만 등록 (안 뜬 소켓으로 connect 시도해서 흔들리는 문제 방지)
    servers=""
    p=1
    while [ "$p" -le "$PROCESS_COUNT" ]; do
        t=0
        while [ "$t" -lt "$THREAD_COUNT" ]; do
        sock="${SOCK_DIR}/${SOCK_PREFIX}_${p}_${t}.sock"
        if [ -S "$sock" ]; then
            servers="${servers}    server ws_${p}_${t} unix@${sock} maxconn ${SERVER_MAXCONN}\n"
        else
            echo "[haproxy] WARN missing socket: $sock" >&2
        fi
        t=$((t+1))
        done
        p=$((p+1))
    done

    awk -v repl="$(printf "%b" "$servers")" '{gsub(/__SERVERS__/, repl)}1' "$TPL" > "$OUT"

    echo "=== rendered haproxy.cfg ==="
    cat "$OUT"

    exec haproxy -f "$OUT" -db